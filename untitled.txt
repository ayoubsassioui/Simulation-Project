/*variables de décisions */
dvar boolean y[i][j];
/*====Les indices =======*/
int n= ...;
int nmax ;
range n=1..nmax;

int i=...;
int s=...;
range i=1..s;/* i représente le iéme système */

int j=...;/* j représente les systèmes disponibles */
int mi=...;
range i=..mi

int k=...;
range k=1..kmax;

int p=...;
range p=K..nmax;

int C;
int W;

integer Lambda[i][j];
int t;/* temps de mission il est fixé */
float alpha [i][j];
float beta [i][j] ;
int c[][];
int w[][];
float nu[][];
 {string} Type=...;
 /* Partition each subsystem i into sets A, S and N.
A = set of all subsystems limited to active redundancy
S = set of all subsystems limited to cold-standby redundancy
N = set of all subsystems which will not use additional redundancy (ni = ki)*/
 /* les différents valeurs de nu en fonction de type de la redondance */
execute VERIFY{
   var i ;
   for (i in Type = "A")
      if p =k[i]
         nu[i][j]== -lamda[i][j]*k[i]*t
             /* implémenter le factoriel */
      else nu[i][j] == ln(sum k[i])*(exp(-lamda[i][j]*t)**k[i](1-exp(lamda[i][j])))**n[i]-k[i])
}

execute VERIFY{
   var i ;
   for (i in Type = "S")
      if p =k[i]
         nu[i][j]== -lamda[i][j]*k[i]*t
             /* implémenter le factoriel */
      else nu[i][j] == -lamda[i][j]*k[i]*t
}

execute VERIFY{
   var i ;
   for (i in Type = "N")
      if p =k[i] and nmax=k[i]
         nu[i][j]== -lamda[i][j]*k[i]*t
}

/* Etape 3*/
Maximize sum(i in 1..s,j in 1..m,p in k..m) nu[i][j]*y[i][j];
   subject to {
sum(i in 1..s) sum(j in 1..m) sum(p in K..m) alpha[i][j]*y[i][j]<=c[i][j];
sum(i in 1..s) sum(j in 1..m) sum(p in K..m) beta[i][j]*y[i][j]<=w[i][j];
}

